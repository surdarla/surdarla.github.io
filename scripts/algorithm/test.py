"""3046
두 숫자 R1과 R2가 있을 때, 두 수의 평균 S는 (R1+R2)/2와 같다.
상근이는 정인이 생일 선물로 두 숫자 R1과 R2를 주려고 한다.
생일 파티에서 상근이는 정인이에게 이 두 숫자를 말해주고, 정인이는 이 숫자를 받아 적는다.
그리고 나서 기쁜 마음으로 1년동안 이 숫자를 외우면서 산다.

상근이는 R1과 R2를 엄청난 고민 끝에 정했다.
작년에는 R1과 R2를 까먹어서 아무 숫자나 정해서 주었기 때문에,
올해는 까먹지 않기 위해서 평균 S도 같이 기억하려고 한다.

오늘은 정인이 생일이다.
5분 후에 상근이는 생일 선물로 두 숫자 R1과 R2를 말해주어야 하지만,
안타깝게도 R2를 까먹고 말았다. 하지만 R1과 S는 기억하고 있다!

상근이를 도와 R2가 몇 인지 구하는 프로그램을 작성하시오.

첫째 줄에 두 정수 R1과 S가 주어진다.
두 수는 -1000보다 크거나 같고, 1000보다 작거나 같다.
"""
# r1,s = map(int,input().split())
# r2 = int(2*s - r1)
# print(r2)

"""2163
정화는 N×M 크기의 초콜릿을 하나 가지고 있다.
초콜릿은 금이 가 있는 모양을 하고 있으며,
그 금에 의해 N×M개의 조각으로 나눠질 수 있다.

초콜릿의 크기가 너무 크다고 생각한 그녀는 초콜릿을 친구들과 나눠 먹기로 했다.
이를 위해서 정화는 초콜릿을 계속 쪼개서 총 N×M개의 조각으로 쪼개려고 한다.
초콜릿을 쪼갤 때에는 초콜릿 조각을 하나 들고, 적당한 위치에서 초콜릿을 쪼갠다.
초콜릿을 쪼갤 때에는 금이 가 있는 위치에서만 쪼갤 수 있다.
이와 같이 초콜릿을 쪼개면 초콜릿은 두 개의 조각으로 나눠지게 된다.
이제 다시 이 중에서 초콜릿 조각을 하나 들고, 쪼개는 과정을 반복하면 된다.

초콜릿을 쪼개다보면 초콜릿이 녹을 수 있기 때문에,
정화는 가급적이면 초콜릿을 쪼개는 횟수를 최소로 하려 한다.
초콜릿의 크기가 주어졌을 때, 이를 1×1 크기의 초콜릿으로 쪼개기 위한
최소 쪼개기 횟수를 구하는 프로그램을 작성하시오.

첫째 줄에 두 정수 N, M(1 ≤ N, M ≤ 300)이 주어진다.

input : 2 2
output : 3

dynamic programming : 문제 안에 문제
세로로 한번 쫙 쪼개면 n-1번
그리고 하나하나를 가로로만 쪼개면 m-1번이다
이걸 n-1번 만큼 해줘야하니깐
식은 (m-1) * (m-1)(n-1) 이렇게 나온다
정리하면 m * (n-1)이 된다.

def program(n,m):
    return n * m-1
n,m = map(int,input().split())
print(program(n,m))
"""

# 10699 오늘날짜 브론즈 5


# | 시간제한 | 메모리제한| 정답비율|
# |:---:|:---:|:---:|
# |1초|256MB|56%|

# '''
# 서울의 오늘 날짜를 출력(YYYY-MM-DD)하는 프로그램 작성
# '''
# from datetime import datetime, timezone, timedelta
# import time
# today = datetime.now(tz=timezone(timedelta(hours=9))).strftime("%Y-%m-%d")
# print(today)

# 7287 등록 브론즈 5

# | 시간제한 | 메모리제한| 정답비율|
# |:---:|:---:|:---:|
# |1초|128MB|51%|

# '''
# 자신이 백준 온라인 저지에서 맞은 문제의 수와 아이디를 그대로 출력하는 프로그램 작성
# '''
# print('rlskejdk')
# print('64')

# 2164 카드 2 실버4
# | 시간제한 | 메모리제한| 정답비율|
# |:---:|:---:|:---:|
# |2초|128MB|50.9%|

"""
N장의 카드가 있다.
각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며,
1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.

이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다.
우선, 제일 위에 있는 카드를 바닥에 버린다.
그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.

예를 들어 N=4인 경우를 생각해 보자.
카드는 제일 위에서부터 1234 의 순서로 놓여있다.
1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다.
3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다.
마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.

N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.
1<=N<=500,000
6->4
"""
# from collections import deque
# import sys

# def step1(dq):
#     dq.popleft()
#     return dq

# def step2(dq):
#     dq.rotate(-1)
#     return dq

# if __name__ == '__main__':
#     input = sys.stdin.readline
#     n = int(input())
#     n_dq = deque([i for i in range(1,n+1)])
#     while len(n_dq) != 1:
#         n_dq = step1(n_dq)
#         n_dq = step2(n_dq)
#     print(*n_dq)
